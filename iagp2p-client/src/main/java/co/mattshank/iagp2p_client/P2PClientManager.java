package co.mattshank.iagp2p_client;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.logging.LogManager;

import co.mattshank.iagp2p_client.objects.P2PProperties;
import co.mattshank.iagp2p_client.objects.P2PTorrent;

public class P2PClientManager {
	private static final boolean runInfinitely = true;
	
	public static void main(String[] args) throws NoSuchAlgorithmException, IOException, InterruptedException {
		Properties properties;
		String configPath = "";
		P2PTorrentBuilder torrentBuilder;
		P2PTorrentReceiver torrentReceiver;
		HashMap<String, P2PClient> seedingClients = new HashMap<String, P2PClient>();
		boolean disableClientLogging = true;
		
		System.out.println("---------------------------------------------------------------");
		System.out.println("\t   iagp2p-client (v1.0)");
		System.out.println("---------------------------------------------------------------");
		System.out.println("\t  Developed by Matt Shank");
		System.out.println("\twww.github.com/shankm/iagp2p");
		System.out.println("\t GNU GENERAL PUBLIC LICENSE");
		System.out.println("\t  Version 3, 29 June 2007");
		System.out.println("---------------------------------------------------------------");
		
		configPath = args.length > 0 ? args[0] : "src/main/resources/client.properties";
		System.out.println("properties: " + configPath + "\n");
		
		// Check whether to disable logging from the torrent client
		if(args.length == 1)
			disableClientLogging = false;
		else if (args.length >= 2 && args[1].equals("-n"))
			disableClientLogging = true;
		if(disableClientLogging)
			LogManager.getLogManager().reset();
		
		// Gather properties to use for duration of execution
		List<String> requiredProperties = new ArrayList<String>();
		// Define list of required properties
		requiredProperties.add("home_agency_id");
		requiredProperties.add("listen_interface");
		requiredProperties.add("torrent_incoming_directory");
		requiredProperties.add("incoming_file_directory");
		requiredProperties.add("home_file_directory");
		requiredProperties.add("home_file_archive_directory");
		requiredProperties.add("torrent_outgoing_directory");
		requiredProperties.add("tracker_ip");
		requiredProperties.add("tracker_port");
		requiredProperties.add("torrent_distributor_ip");
		requiredProperties.add("torrent_distributor_port");
		requiredProperties.add("torrent_seeding_incoming_directory");
		
		// Configurable properties from config.properties
		properties = P2PProperties.loadProperties(configPath, requiredProperties);
		
		if(properties == null) {
			System.err.println("All required properties must be defined in client.properties:");
			for (String s : requiredProperties) {
				if (s != null)
					System.err.println("- " + s);
			}
			System.exit(1);
		}
		
		// Start a separate thread to build new torrents for any outgoing files generated by the home CSC
		System.out.print("Initializing torrent builder... ");
		System.out.flush();
		torrentBuilder = new P2PTorrentBuilder(properties);
		torrentBuilder.start();
		System.out.println("SUCCESS");
	
		// Start a separate thread to build new torrents for any outgoing files generated by the home CSC
		System.out.print("Initializing torrent receiver... ");
		System.out.flush();
		torrentReceiver = new P2PTorrentReceiver(properties);
		torrentReceiver.start();
		System.out.println("SUCCESS");
		
		do {
			// Download and share files
			seedingClients = downloadAndSeedFiles(properties, seedingClients);
//			for(String key : seedingClients.keySet()) {
//				//System.out.println(key + ": " + sharingClients.get(key).getStatus());
//			}
			
			// Copy fully downloaded files to incoming_file_directory to be processed by iagp2p-middle
			copyDownloadedFilesToLoad(properties);
			
			// Make sure other threads are still running. If not, start new ones.
			if(torrentBuilder.getState() == Thread.State.TERMINATED) {
				System.out.println("ERROR: The torrent builder unexpectedly terminated.");
				System.out.print("Re-initializing torrent builder... ");
				System.out.flush();
				torrentBuilder = new P2PTorrentBuilder(properties);
				torrentBuilder.start();
				System.out.println("SUCCESS");
			}
		
			if(torrentReceiver.getState() == Thread.State.TERMINATED) {
				System.out.println("ERROR: The torrent receiver unexpectedly terminated.");
				System.out.print("Re-initializing torrent receiver... ");
				System.out.flush();
				torrentReceiver = new P2PTorrentReceiver(properties);
				torrentReceiver.start();
				System.out.println("SUCCESS");
			}
			
			Thread.sleep(5000);
		} while(runInfinitely);
	}
	
	private static HashMap<String, P2PClient> downloadAndSeedFiles(Properties properties, HashMap<String, P2PClient> sharingClients) {
		HashMap<String, P2PClient> newSeedingClients = new HashMap<String, P2PClient>(sharingClients);
		File[] listOfFiles;
		P2PTorrent torrentTemp;
		
		// Home files outgoing
		listOfFiles = new File(
				properties.getProperty("torrent_outgoing_directory")).listFiles(
						new FilenameFilter() {
							public boolean accept(File dir, String name) {
								boolean temp = false;
								if (name.toLowerCase().endsWith(".torrent"))
									temp = true;
								return temp;
							}
						});
		for(File f : listOfFiles) {
			if(!newSeedingClients.containsKey(f.getName())) {
				try {
					// Initialize new torrent object to provide to the torrent sender and client
					torrentTemp = new P2PTorrent(properties, f, true);
					
					// Share the new torrent with the tracker
					new P2PTorrentSender(properties, torrentTemp).start();
					
					// Begin sharing the file with the swarm
					newSeedingClients.put(f.getName(), new P2PClient(properties, torrentTemp));
					newSeedingClients.get(f.getName()).shareFile();
					System.out.println("Sharing " + f.getName());
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		
		// Downloaded away files outgoing
		listOfFiles = new File(
				properties.getProperty("torrent_incoming_directory")).listFiles(
						new FilenameFilter() {
							public boolean accept(File dir, String name) {
								boolean temp = false;
								if (name.toLowerCase().endsWith(".torrent"))
									temp = true;
								return temp;
							}
						});
		for(File f : listOfFiles) {
			if(!newSeedingClients.containsKey(f.getName())) {
				try {
					// Initialize new torrent object to provide to the torrent sender and client
					torrentTemp = new P2PTorrent(properties, f, false);
					
					// Begin downloading and sharing the file with the swarm
					newSeedingClients.put(f.getName(), new P2PClient(properties, torrentTemp));
					newSeedingClients.get(f.getName()).shareFile();
				} catch (UnknownHostException e) {
					e.printStackTrace();
				}
			}
		}
		
		return newSeedingClients;
	}
	
	private static void copyDownloadedFilesToLoad(Properties properties) {
		File[] listOfFiles;
		
		listOfFiles = P2PTorrentBuilder.sortFilesChronologically(new File(
				properties.getProperty("torrent_seeding_incoming_directory")).listFiles(
						new FilenameFilter() {
							public boolean accept(File dir, String name) {
								boolean temp = false;
								if ((name.toLowerCase().endsWith(".itag") || name.toLowerCase().endsWith(".iclp") || name.toLowerCase().endsWith(".itgu")))
									temp = true;
								return temp;
							}
						}));
		for(File f : listOfFiles) {
			String destinationPath = properties.getProperty("incoming_file_directory") + f.getName();
			String tempDestinationPath = destinationPath + ".part";
			File destinationFile = new File(destinationPath);
			Path temp;
			
			if(!(destinationPath == null || destinationPath == "" || destinationFile.exists())) {
				try {
					temp = Files.copy(Paths.get(f.getAbsolutePath()), Paths.get(tempDestinationPath), StandardCopyOption.REPLACE_EXISTING);
				
					if(temp != null)
						new File(tempDestinationPath).renameTo(destinationFile);

				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}

}
